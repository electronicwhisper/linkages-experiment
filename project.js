// Generated by CoffeeScript 1.6.3
(function() {
  var AngleConstraint, DistanceConstraint, Point, canvasEl, clear, config, ctx, drawCircle, drawLine, drawPoint, enforceConstraints, findPointNear, gradient, idle, idleLoop, init, math, model, pointerDown, pointerMove, pointerUp, render, resize, uistate;

  canvasEl = document.querySelector("#c");

  ctx = canvasEl.getContext("2d");

  resize = function() {
    var rect;
    rect = canvasEl.getBoundingClientRect();
    canvasEl.width = rect.width;
    canvasEl.height = rect.height;
    return render();
  };

  init = function() {
    window.addEventListener("resize", resize);
    canvasEl.addEventListener("pointerdown", pointerDown);
    canvasEl.addEventListener("pointermove", pointerMove);
    canvasEl.addEventListener("pointerup", pointerUp);
    resize();
    return idleLoop();
  };

  idleLoop = function() {
    idle();
    return requestAnimationFrame(idleLoop);
  };

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  DistanceConstraint = (function() {
    function DistanceConstraint(p1, p2, distance) {
      this.p1 = p1;
      this.p2 = p2;
      this.distance = distance;
    }

    DistanceConstraint.prototype.points = function() {
      return [this.p1, this.p2];
    };

    DistanceConstraint.prototype.error = function() {
      var d, e;
      d = math.distance(this.p1, this.p2);
      e = d - this.distance;
      return e * e;
    };

    return DistanceConstraint;

  })();

  AngleConstraint = (function() {
    function AngleConstraint(p1, p2, angle) {
      this.p1 = p1;
      this.p2 = p2;
      this.angle = angle;
    }

    AngleConstraint.prototype.points = function() {
      return [this.p1, this.p2];
    };

    AngleConstraint.prototype.error = function() {
      var angle, da, e;
      angle = math.angle(this.p1, this.p2);
      da = angle - this.angle;
      e = math.distance(this.p1, this.p2) * Math.sin(da);
      return e * e;
    };

    return AngleConstraint;

  })();

  model = {
    points: [],
    constraints: []
  };

  uistate = {
    movingPoint: null,
    lastPoints: [],
    pointerX: 0,
    pointerY: 0
  };

  clear = function() {
    var height, width;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    width = ctx.canvas.width;
    height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);
    return ctx.restore();
  };

  drawPoint = function(point, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    return ctx.fill();
  };

  drawCircle = function(center, radius, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  drawLine = function(p1, p2, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  render = function() {
    var color, constraint, point, _i, _j, _len, _len1, _ref, _ref1, _results;
    clear();
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      color = "#000";
      if (point === uistate.lastPoints[0]) {
        color = "#f00";
      }
      if (point === uistate.lastPoints[1]) {
        color = "#a00";
      }
      drawPoint(point, color);
      if (point.fixed) {
        drawCircle(point, 5, color);
      }
    }
    _ref1 = model.constraints;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      constraint = _ref1[_j];
      if (constraint instanceof DistanceConstraint) {
        drawLine(constraint.p1, constraint.p2, "blue");
      }
      if (constraint instanceof AngleConstraint) {
        _results.push(drawLine(constraint.p1, constraint.p2, "red"));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  findPointNear = function(p) {
    var point, _i, _len, _ref;
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (math.distance(p, point) < 10) {
        return point;
      }
    }
    return void 0;
  };

  pointerDown = function(e) {
    var foundPoint, p;
    p = new Point(e.clientX, e.clientY);
    foundPoint = findPointNear(p);
    if (!foundPoint) {
      model.points.push(p);
      foundPoint = p;
    }
    uistate.movingPoint = foundPoint;
    if (uistate.lastPoints[0] !== foundPoint) {
      return uistate.lastPoints.unshift(foundPoint);
    }
  };

  pointerMove = function(e) {
    uistate.pointerX = e.clientX;
    return uistate.pointerY = e.clientY;
  };

  pointerUp = function(e) {
    if (uistate.movingPoint) {
      return uistate.movingPoint = null;
    }
  };

  idle = function() {
    if (uistate.movingPoint) {
      uistate.movingPoint.x = uistate.pointerX;
      uistate.movingPoint.y = uistate.pointerY;
    }
    enforceConstraints();
    return render();
  };

  key("D", function() {
    var constraint, distance, p1, p2;
    p1 = uistate.lastPoints[0];
    p2 = uistate.lastPoints[1];
    distance = math.distance(p1, p2);
    constraint = new DistanceConstraint(p1, p2, distance);
    model.constraints.push(constraint);
    return render();
  });

  key("A", function() {
    var angle, constraint, p1, p2;
    p1 = uistate.lastPoints[0];
    p2 = uistate.lastPoints[1];
    angle = math.angle(p1, p2);
    constraint = new AngleConstraint(p1, p2, angle);
    model.constraints.push(constraint);
    return render();
  });

  key("F", function() {
    var p;
    p = uistate.lastPoints[0];
    return p.fixed = !p.fixed;
  });

  math = {};

  math.distance = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  };

  math.angle = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return Math.atan2(dy, dx);
  };

  math.normalize = function(p) {
    var d;
    d = Math.sqrt(p.x * p.x + p.y * p.y);
    return new Point(p.x / d, p.y / d);
  };

  window.config = config = {
    epsilon: 1e-2,
    stepSize: 0.1,
    maxIterations: 600
  };

  enforceConstraints = function() {
    var constraint, d, derivative, derivatives, e, fixedPoints, i, iteration, move, moves, point, relevantPoints, step, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _results;
    fixedPoints = [];
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (point.fixed) {
        fixedPoints.push(point);
      }
    }
    _results = [];
    for (iteration = _j = 0, _ref1 = config.maxIterations; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; iteration = 0 <= _ref1 ? ++_j : --_j) {
      moves = [];
      _ref2 = model.constraints;
      for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
        constraint = _ref2[_k];
        e = constraint.error();
        if (e > config.epsilon) {
          relevantPoints = constraint.points();
          relevantPoints = _.difference(relevantPoints, fixedPoints);
          derivatives = gradient(constraint, relevantPoints);
          moves.push({
            points: relevantPoints,
            derivatives: derivatives,
            error: e
          });
        }
      }
      if (moves.length === 0) {
        break;
      }
      _results.push((function() {
        var _l, _len2, _results1;
        _results1 = [];
        for (_l = 0, _len2 = moves.length; _l < _len2; _l++) {
          move = moves[_l];
          _results1.push((function() {
            var _len3, _m, _ref3, _results2;
            _ref3 = move.points;
            _results2 = [];
            for (i = _m = 0, _len3 = _ref3.length; _m < _len3; i = ++_m) {
              point = _ref3[i];
              derivative = move.derivatives[i];
              d = math.normalize(derivative);
              step = Math.sqrt(move.error) * config.stepSize;
              point.x -= d.x * step;
              _results2.push(point.y -= d.y * step);
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  gradient = function(constraint, points) {
    var delta, derivative, derivatives, e1, e2, i, original, point, _i, _j, _len, _len1, _ref;
    delta = 1e-10;
    derivatives = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      derivative = new Point();
      derivatives.push(derivative);
      _ref = ["x", "y"];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        i = _ref[_j];
        original = point[i];
        e1 = constraint.error();
        point[i] += delta;
        e2 = constraint.error();
        point[i] = original;
        derivative[i] = (e2 - e1) / delta;
      }
    }
    return derivatives;
  };

  init();

}).call(this);
