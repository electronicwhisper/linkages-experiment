// Generated by CoffeeScript 1.6.3
(function() {
  var AngleConstraint, DistanceConstraint, Point, SpreadConstraint, canvasEl, clear, ctx, drawArc, drawLine, drawPoint, enforceConstraints, findPointNear, gradient, idle, idleLoop, init, math, model, pointerDown, pointerMove, pointerUp, render, resize, uistate;

  canvasEl = document.querySelector("#c");

  ctx = canvasEl.getContext("2d");

  resize = function() {
    var rect;
    rect = canvasEl.getBoundingClientRect();
    canvasEl.width = rect.width;
    canvasEl.height = rect.height;
    return render();
  };

  init = function() {
    window.addEventListener("resize", resize);
    canvasEl.addEventListener("pointerdown", pointerDown);
    canvasEl.addEventListener("pointermove", pointerMove);
    canvasEl.addEventListener("pointerup", pointerUp);
    idleLoop();
    return resize();
  };

  idleLoop = function() {
    idle();
    return requestAnimationFrame(idleLoop);
  };

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.coordinates = ["x", "y"];

    return Point;

  })();

  DistanceConstraint = (function() {
    function DistanceConstraint(p1, p2, quadrance) {
      this.p1 = p1;
      this.p2 = p2;
      this.quadrance = quadrance;
    }

    DistanceConstraint.prototype.coordinates = ["p1", "p2"];

    DistanceConstraint.prototype.points = function() {
      return [this.p1, this.p2];
    };

    DistanceConstraint.prototype.error = function() {
      var dq, q;
      q = math.quadrance(this.p1, this.p2);
      dq = q - this.quadrance;
      return dq * dq;
    };

    return DistanceConstraint;

  })();

  AngleConstraint = (function() {
    function AngleConstraint(p1, p2, angle) {
      this.p1 = p1;
      this.p2 = p2;
      this.angle = angle;
    }

    AngleConstraint.prototype.points = function() {
      return [this.p1, this.p2];
    };

    AngleConstraint.prototype.error = function() {
      var a, da;
      a = math.angle(this.p1, this.p2);
      da = a - this.angle;
      da *= 10000;
      return da * da;
    };

    return AngleConstraint;

  })();

  SpreadConstraint = (function() {
    function SpreadConstraint(p1, p2, spread) {
      this.p1 = p1;
      this.p2 = p2;
      this.spread = spread;
    }

    SpreadConstraint.prototype.points = function() {
      return [this.p1, this.p2];
    };

    SpreadConstraint.prototype.error = function() {
      var ds, s;
      s = math.spread(this.p1, this.p2);
      ds = s - this.spread;
      ds *= 1000000;
      return ds * ds;
    };

    return SpreadConstraint;

  })();

  model = {
    points: [],
    constraints: []
  };

  uistate = {
    movingPoint: null,
    lastPoints: []
  };

  clear = function() {
    var height, width;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    width = ctx.canvas.width;
    height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);
    return ctx.restore();
  };

  drawPoint = function(point, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    return ctx.fill();
  };

  drawLine = function(p1, p2, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  drawArc = function(center, r, a1, a2, color) {
    if (color == null) {
      color = "#000";
    }
    ctx.beginPath();
    ctx.arc(center.x, center.y, r, a1, a2);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  render = function() {
    var constraint, point, _i, _j, _len, _len1, _ref, _ref1, _results;
    clear();
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (point.fixed) {
        drawPoint(point, "black");
      } else {
        drawPoint(point, "grey");
      }
    }
    _ref1 = model.constraints;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      constraint = _ref1[_j];
      if (constraint instanceof DistanceConstraint) {
        drawLine(constraint.p1, constraint.p2, "blue");
      }
      if (constraint instanceof SpreadConstraint) {
        _results.push(drawLine(constraint.p1, constraint.p2, "red"));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  findPointNear = function(p) {
    var point, _i, _len, _ref;
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (math.quadrance(p, point) < 100) {
        return point;
      }
    }
    return void 0;
  };

  pointerDown = function(e) {
    var foundPoint, p;
    p = new Point(e.clientX, e.clientY);
    foundPoint = findPointNear(p);
    if (!foundPoint) {
      model.points.push(p);
      foundPoint = p;
    }
    uistate.movingPoint = foundPoint;
    if (uistate.lastPoints[0] !== foundPoint) {
      uistate.lastPoints.unshift(foundPoint);
    }
    return render();
  };

  pointerMove = function(e) {
    if (uistate.movingPoint) {
      uistate.movingPoint.x = e.clientX;
      uistate.movingPoint.y = e.clientY;
      enforceConstraints();
    }
    return render();
  };

  pointerUp = function(e) {
    if (uistate.movingPoint) {
      uistate.movingPoint = null;
    }
    return render();
  };

  idle = function() {};

  key("d", function() {
    var constraint, p1, p2, quadrance;
    p1 = uistate.lastPoints[0];
    p2 = uistate.lastPoints[1];
    quadrance = math.quadrance(p1, p2);
    constraint = new DistanceConstraint(p1, p2, quadrance);
    model.constraints.push(constraint);
    return render();
  });

  key("a", function() {
    var constraint, p1, p2, spread;
    p1 = uistate.lastPoints[0];
    p2 = uistate.lastPoints[1];
    spread = math.spread(p1, p2);
    constraint = new SpreadConstraint(p1, p2, spread);
    model.constraints.push(constraint);
    return render();
  });

  key("f", function() {
    var p;
    p = uistate.lastPoints[0];
    return p.fixed = true;
  });

  math = {};

  math.quadrance = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  };

  math.angle = function(p1, p2) {
    var dx, dy;
    dx = p2.x - p1.x;
    dy = p2.y - p1.y;
    return Math.atan2(dy, dx);
  };

  math.spread = function(p1, p2) {
    var dy;
    dy = p2.y - p1.y;
    return dy * dy / math.quadrance(p1, p2);
  };

  math.normalize = function(p) {
    var d;
    d = Math.sqrt(p.x * p.x + p.y * p.y);
    return new Point(p.x / d, p.y / d);
  };

  enforceConstraints = function() {
    var constraint, d, derivative, derivatives, e, epsilon, fixedPoints, i, iteration, move, moves, point, relevantPoints, stepSize, _i, _j, _k, _len, _len1, _ref, _ref1, _results;
    epsilon = 1e3;
    stepSize = 1e-6;
    fixedPoints = [];
    _ref = model.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      if (point.fixed) {
        fixedPoints.push(point);
      }
    }
    _results = [];
    for (iteration = _j = 0; _j < 100; iteration = ++_j) {
      moves = [];
      _ref1 = model.constraints;
      for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
        constraint = _ref1[_k];
        e = constraint.error();
        if (e > epsilon) {
          relevantPoints = constraint.points();
          relevantPoints = _.difference(relevantPoints, fixedPoints);
          derivatives = gradient(constraint, relevantPoints);
          moves.push({
            points: relevantPoints,
            derivatives: derivatives
          });
        }
      }
      if (moves.length === 0) {
        break;
      }
      _results.push((function() {
        var _l, _len2, _results1;
        _results1 = [];
        for (_l = 0, _len2 = moves.length; _l < _len2; _l++) {
          move = moves[_l];
          _results1.push((function() {
            var _len3, _m, _ref2, _results2;
            _ref2 = move.points;
            _results2 = [];
            for (i = _m = 0, _len3 = _ref2.length; _m < _len3; i = ++_m) {
              point = _ref2[i];
              derivative = move.derivatives[i];
              d = math.normalize(derivative);
              point.x -= d.x;
              _results2.push(point.y -= d.y);
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  gradient = function(constraint, points) {
    var delta, derivative, derivatives, e1, e2, i, original, point, _i, _j, _len, _len1, _ref;
    delta = 1e-8;
    derivatives = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      derivative = new Point();
      derivatives.push(derivative);
      _ref = point.coordinates;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        i = _ref[_j];
        original = point[i];
        e1 = constraint.error();
        point[i] += delta;
        e2 = constraint.error();
        point[i] = original;
        derivative[i] = (e2 - e1) / delta;
      }
    }
    return derivatives;
  };

  init();

}).call(this);
